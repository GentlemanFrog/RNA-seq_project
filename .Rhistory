sd(x)
dbinom(10, 4, 0.5)
dbinom(4, 10, 0.5)
1-pbibnom(3, 10, 0.5)
1-pbinom(3, 10, 0.5)
pbinom(6, 10, 0.5)
pbinom(4, 10, 0.5)
dane_zad3=read.csv("http://www.combio.pl/files/p53_mouse.csv")
View(dane_zad3)
View(dane_zad3)
shapiro.test(dane_zad3)
shapiro.test(dane_zad3$wt)
shapiro.test(dane_zad3$mut)
#zad3
dane_zad3=read.csv("http://www.combio.pl/files/p53_mouse.csv")
shapiro.test(dane_zad3$wt)
shapiro.test(dane_zad3$mut)
wilcox.test(dane_zad3$mut, dane_zad3$wt,
conf.level = 0.99, alternative = "less")
x = c(1, 8, 2, 6, 3, 8, 5, 5, 5, 5)
mean(days)
#zad4
days = c(1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 7, 7)
mean(days)
m=mean(days)
t.test(days, mu=m)
t.test(days, mu=3)
#Zad 5
machine = c(68, 82, 94, 106, 92, 80, 76, 74, 110, 93, 86, 65, 74, 84, 100)
doctor = c(72, 84, 89, 100, 97, 88, 84, 70, 103, 84, 86, 63, 69, 87, 93)
shapiro.test(machine)
shapiro.test(doctor)
t.test(machine, doctor, paired = TRUE)
t.test(machine, doctor, paired = TRUE, alternative = "less")
#Zad 6
chisq.test(c(38, 72, 40), p=c(0.2, 0.3, 0.5))
#Zad 6
chisq.test(c(38, 72, 40), p=c(0.2, 0.5, 0.3))
#Zad 7
x = read.csv("http://www.combio.pl/files/student_weights.csv")
View(x)
shapiro.test(x$before)
shapiro.test(x$after)
t.test(x$before, x$after, paired = TRUE, alternative = "less")
#Zad8
y = read.csv("http://www.combio.pl/files/bacteria.csv")
View(y)
y$pathogenic
shapiro.test(y$pathogenic)
shapiro.test(y$normal)
var.test(y$pathogenic)
var.test(y$pathogenic, y$normal)
t.test(y$pathogenic, y$normal, var.equal = TRUE)
t.test(y$pathogenic, y$normal, var.equal = TRUE, alternative = "greater")
x = read.csv("http://www.combio.pl/files/exam.csv")
View(x)
a = read.csv("http://www.combio.pl/files/exam.csv")
cor(a$hours, a$points)
show(a)
cor(a$hours, a$points)
with(a, lm(points~hours))
model(a, lm(points~hours))
model = lm(formula = points~hours, data = a)
View(model)
View(model)
model
summary(model)
predict(model, data.frame(hours=c(5)))
#zad2
m = read.csv("http://www.combio.pl/files/mice.csv")
View(m)
shapiro.test(m$WT)
shapiro.test(m$MUT)
var.test(m$WT, m$MUT)
t.test(m$WT, m$MUT, var.equal = F)
tet = read.csv("http://www.combio.pl/files/pulse.csv")
View(tet)
shapiro.test(tet$before)
shapiro.test(tet$after)
t.test(tet$before, tet$after, paired = T, alternative = "less", conf.level = .99)
owa = read.csv("http://www.combio.pl/files/InsectSprays.csv")
owa = read.csv("http://www.combio.pl/files/InsectSprays.csv")
View(owa)
bartlett.test(owa$count~owa$spray)
kruskal.test(owa$count~owa$spray)
pairwise.wilcox.test(owa$count, owa$spray, exact=F)
seadeep = c(862, 870, 876, 866, 871)
seaDeep = c(862, 870, 876, 866, 871)
t.test(seaDeep, mu = 870, conf.level = .99)
#Do tych zadań niezbędne jest zainstalowanei paczki lavaan
#install.packages("lavaan", dependencies=TRUE)
#odpalamy paczke w środowisku:
library(lavaanPlot)
install.packages("lavaanPlot")
install.packages("lavaan")
remove.packages("lavaan")
install.packages("lavaanPLot")
install.packages("lavaanPlot")
install.packages("DiagrammeR")
library(gluea)
library(glue)
remove.packages("glue")
remove.packages("glue")
install.packages("DiagrammeR", dependencies = TRUE, clean = TRUE)
install.packages("DiagrammeR", dependencies = TRUE, clean = TRUE)
old.packages()
update.packages("glue")
old.packages()
library(glue)
install.packages("glue", dependencies = TRUE, clean = TRUE)
install.packages("glue", dependencies = TRUE, clean = TRUE)
old.packages()
install.packages("installr")
library(installr)
updateR()
r
R.version()
R.version
setwd("C:/Users/Alek/Desktop/RNA-seq_project")
library(DESeq2)
library(tidyverse)
library(airway)
data(airway)
airway
# Changing the data to data_frame
sample_info <- as.data.frame(colData(airway))
# Restricting the data only to interesting columns
sample_info <- sample_info[,c(2,3)]
# Changing the data to data_frame
sample_info <- as.data.frame(colData(airway))
# Restricting the data only to interesting columns
sample_info <- sample_info[,c(2,3)]
# Replacing shortcuts with proper name for column dex
sample_info$dex <- gsub('trt', 'treated', sample_info$dex)
sample_info$dex <- gsub('untrt', 'untreated', sample_info$dex)
# Renaming the column names: cell, dex to more descriptive names
names(sample_info) <- c('cellLine', 'dexamethasone')
# Writing chosen data info into csv file
write.table(sample_info, file = "sample_info.csv", sep = ',',
col.names = T, row.names = T, quote = F)
# Preparing data of experiment where rows are genes, columns are counts for each sample and gene
countsData <- assay(airway)
# Renaming the column names: cell, dex to more descriptive names
names(sample_info) <- c('cellLine', 'dexamethasone')
# Writing chosen data info into csv file
write.table(sample_info, file = "sample_info.csv", sep = ',',
col.names = T, row.names = T, quote = F)
# Preparing data of experiment where rows are genes, columns are counts for each sample and gene
countsData <- assay(airway)
# Writing count data info into csv file
write.table(countsData, file = "counts_data.csv", sep = ',',
col.names = T, row.names = T, quote = F)
# Reading in counts data from csv:
counts_data<- read.csv('counts_data.csv')
# we see the rows are gene IDs (Ensemble), columns are the sample name but by this names
# we don't know which samples are treated and which one are untreated which we will set up
head(counts_data)
# Reading the sample_info:
column_data<-read.csv('sample_info.csv')
head(column_data)
# To perform calculations with DESeq we have to check the row names of column_data
# matches the names in counts_data.
# We performing this by checking if all colnames in counts_data are present in column_data
# We get the information in the boolean if there are all of them or not
all(colnames(counts_data) %in% rownames(column_data))
# In addition we check if they are in the same order:
all(colnames(counts_data) == rownames(column_data))
# First argument countData refers to counts genes accross samples, colData refers to data about cell line of each sample
# that we are checking and information about it being treated with drug or not, design is a formula which express
# how the counts for each gene depend on the variables in colData, so for our example we want to check the differences
# between treated and untreated samples so design refers to the dexamethasone column
dds <- DESeqDataSetFromMatrix(countData = counts_data,
colData = column_data,
design = ~ dexamethasone)
dds
# This step allows us to reduce the memory size of the dds object, and increase the speed
# of the transformation and testing functions with DESeq2. It can also improve visualization,
# as features with no information for differential expression will not be plotted
keeped_rows <- rowSums(counts(dds)) >= 10
dds <- dds[keeped_rows,] # we drooped ~ 40k rows with lower than 10 counts
dds
dds$dexamethasone <- relevel(dds$dexamethasone, ref = "untreated")
dds$dexamethasone
# Now the script will perform the standard differential expression analysis, which all steps are wrapped in the single
# function DESeq.
dds <- DESeq(dds)
# Saving results from DESeqData object:
res <- results(dds)
# padj - this column contains adjusted p_values for multiple testing. We have to correct the p_values
#       for multiple testing because whenever the statistical test is performed we use a p value of 0.05.
#       5% of our differential expressed genes are not really differential expressed and they are there due to random chance.
#       To reduce problem of this false positives we perform methods to calculate the adjusted p_values to avoid this detection
#       of false positive genes.
res
# In the summary we can see how many genes are up-regulated, down-regulated, how much of them are outlires
# and how many of them have low counts.
summary(res)
# Also we can change the threshold of adjusted p_values we look at
res_p_0.01 <- results(dds, alpha = 0.01)
summary(res_p_0.01)
# This plot is the plot of log2FC vs the mean of the normalized counts. The genes that are differentially
# expressed are colored in blue. This genes are significantly differentially expressed genes in our example
# also there are visible triangles to the top of the plot, this are genes with the higher foldchanges, and the direction
# triangles tell the direction of the fold change. In this type of plots we want to see genes in the upper right
# part of the plot, which means that these will have high mean of normalized counts and high log2FC values
# which will make these genes candidates to be further look into.
png(file='MA_plot.png')
plotMA(res, ylim=c(-2,2), main = "MA plot of airway data set")
dev.off()
# We performing this step to make more accurate log2FC estimates. This function allows for the shrinkage of the log2FC estimates
# toward zero when the information for a gene is low, which include situations like: low counts, high dispersion values. After usage of
# this function the distribution of LFC estimate for all genes is used to shrink the log2FC estimates of gene with little information
# or high dispersion toward more likely (lower LFC) estimates. (https://github.com/hbctraining/DGE_workshop_salmon/blob/master/lessons/05_DGE_DESeq2_analysis2.md)
resultsNames(dds)
# type = apeglm refers to approximate estimation for GLM coefficients which is the adaptive Student's t prior shrinkage estimator from the 'apeglm' package
resLFC <- lfcShrink(dds, coef = "dexamethasone_treated_vs_untreated", type = "apeglm")
resLFC
# Results after shrinkage:
png(file='MA_plot_after_LFC.png')
plotMA(resLFC, main = "MA plot of airway data set after shrinkage")
dev.off()
# Plot counts - provides  the information of the counts of reads for a single gene across the analysed groups:
# for this plot was provided gen with the smallest adj. p_value from the DESeq results
plotCounts(dds, gene = which.min(res$padj), intgroup = "dexamethasone")
# Saving results ordered by p_pvalue:
resOrdered <- res[order(res$)]
# Saving results ordered by p_pvalue:
resOrdered <- res[order(res$pvalue),]
# Saving results ordered by p_pvalue:
resOrdered <- res[order(res$pvalue),]
write.csv(as.data.frame(resOrdered), file='deseq_results.csv')
res_adj_p <- subset(resOrdered, padj < 0.1)
res_adj_p
# saving filtered results:
write.csv(as.data.frame(res_adj_p), file='adj_p_results.csv')
plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"))
# transformation with VST:
vsd <- vst(dds, blind = FALSE)
head(counts_data)
# After transformation
head(assay(vsd), 3)
library("pheatmap")
# selecting top 20 rows
select <- order(rowMeans(counts(dds, normalized=TRUE)), decreasing = TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("cellLine", "dexamethasone")])
png(filename = "heat_map.png")
pheatmap(assay(vsd)[select,], cluster_rows = FALSE, show_rownames = FALSE,
cluster_cols = FALSE, annotation = df)
dev.off()
# This type of heat map give us an overview of the similarities and differences between groups of samples
# Also the hierarchical clustering is provided based on the sample to sample distance
sampleDistance <- dist(t(assay(vsd)))
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDistance)
rownames(sampleDistMatrix) <- paste(vsd$dexamethasone, vsd$cellLine, sep = "-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette(rev(brewer.pal(9, 'Greens')) )(255)
png(filename = "sample_to_sample_dists.png")
pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDistance,
clustering_distance_cols = sampleDistance,
color = colors)
dev.off()
png(filename = "pca_plot.png")
plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"))
dev.off()
# variable for showing the percentage of variance: (attr function catching only specific attribute of object)
percentVar <- round(100*attr(pcaData, "percentVar"))
pcaData <- plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"), returnData=TRUE)
# variable for showing the percentage of variance: (attr function catching only specific attribute of object)
percentVar <- round(100*attr(pcaData, "percentVar"))
# plotting our custom PCA plot with ggplot:
ggplot(pcaData, aes(PC1, PC2, color=dexamethasone, shape=cellLine))+
geom_point(size=3) +
xlab(paste0("PC1: ", percentVar[1],"% variance"))+
ylab(paste0("PC2: ", percentVar[2], "% variance"))+
coord_fixed()
ggplot(pcaData, aes(PC1, PC2, color=dexamethasone, shape=cellLine))+
geom_point(size=3) +
xlab(paste0("PC1: ", percentVar[1],"% variance"))+
ylab(paste0("PC2: ", percentVar[2], "% variance"))+
coord_fixed()
print(plot(1))
# plotting our custom PCA plot with ggplot:
ggplot(pcaData, aes(PC1, PC2, color=dexamethasone, shape=cellLine))+
geom_point(size=3) +
xlab(paste0("PC1: ", percentVar[1],"% variance"))+
ylab(paste0("PC2: ", percentVar[2], "% variance"))+
coord_fixed()
plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"))
dev.off()
dev.cur()
dev.off(i)
plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"))
# plotting our custom PCA plot with ggplot:
ggplot(pcaData, aes(PC1, PC2, color=dexamethasone, shape=cellLine))+
geom_point(size=3) +
xlab(paste0("PC1: ", percentVar[1],"% variance"))+
ylab(paste0("PC2: ", percentVar[2], "% variance"))+
coord_fixed()
ggsave(filename = "pca_custom.png", plot = last_plot(), device = "png")
ggsave(filename = "pca_custom.png", plot = last_plot(), device = "png")
pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDistance,
clustering_distance_cols = sampleDistance,
color = colors)
png(filename = "sample_to_sample_dists.png")
pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDistance,
clustering_distance_cols = sampleDistance,
color = colors)
dev.off()
# This plot is the plot of log2FC vs the mean of the normalized counts. The genes that are differentially
# expressed are colored in blue. This genes are significantly differentially expressed genes in our example
# also there are visible triangles to the top of the plot, this are genes with the higher foldchanges, and the direction
# triangles tell the direction of the fold change. In this type of plots we want to see genes in the upper right
# part of the plot, which means that these will have high mean of normalized counts and high log2FC values
# which will make these genes candidates to be further look into.
png(file='MA_plot.png')
plotMA(res, ylim=c(-2,2), main = "MA plot of airway data set")
dev.off()
# Results after shrinkage:
png(file='MA_plot_after_LFC.png')
plotMA(resLFC, main = "MA plot of airway data set after shrinkage")
dev.off()
# Plot counts - provides  the information of the counts of reads for a single gene across the analysed groups:
# for this plot was provided gen with the smallest adj. p_value from the DESeq results
plotCounts(dds, gene = which.min(res$padj), intgroup = "dexamethasone")
# Saving results ordered by p_pvalue:
resOrdered <- res[order(res$pvalue),]
write.csv(as.data.frame(resOrdered), file='deseq_results.csv')
res_adj_p <- subset(resOrdered, padj < 0.1)
res_adj_p
# saving filtered results:
write.csv(as.data.frame(res_adj_p), file='adj_p_results.csv')
# transformation with VST:
vsd <- vst(dds, blind = FALSE)
head(counts_data)
# After transformation
head(assay(vsd), 3)
library("pheatmap")
# selecting top 20 rows
select <- order(rowMeans(counts(dds, normalized=TRUE)), decreasing = TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("cellLine", "dexamethasone")])
png(filename = "heat_map.png")
pheatmap(assay(vsd)[select,], cluster_rows = FALSE, show_rownames = FALSE,
cluster_cols = FALSE, annotation = df)
dev.off()
# This type of heat map give us an overview of the similarities and differences between groups of samples
# Also the hierarchical clustering is provided based on the sample to sample distance
sampleDistance <- dist(t(assay(vsd)))
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDistance)
rownames(sampleDistMatrix) <- paste(vsd$dexamethasone, vsd$cellLine, sep = "-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette(rev(brewer.pal(9, 'Greens')) )(255)
png(filename = "sample_to_sample_dists.png")
pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDistance,
clustering_distance_cols = sampleDistance,
color = colors)
dev.off()
png(filename = "pca_plot.png")
plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"))
dev.off()
pcaData <- plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"), returnData=TRUE)
# variable for showing the percentage of variance: (attr function catching only specific attribute of object)
percentVar <- round(100*attr(pcaData, "percentVar"))
# plotting our custom PCA plot with ggplot:
ggplot(pcaData, aes(PC1, PC2, color=dexamethasone, shape=cellLine))+
geom_point(size=3) +
xlab(paste0("PC1: ", percentVar[1],"% variance"))+
ylab(paste0("PC2: ", percentVar[2], "% variance"))+
coord_fixed()
ggsave(filename = "pca_custom.png", plot = last_plot(), device = "png")
setwd("C:/Users/Alek/Desktop/RNA-seq_project")
library(DESeq2)
library(tidyverse)
library(airway)
data(airway)
airway
# Changing the data to data_frame
sample_info <- as.data.frame(colData(airway))
# Restricting the data only to interesting columns
sample_info <- sample_info[,c(2,3)]
data(airway)
airway
# Changing the data to data_frame
sample_info <- as.data.frame(colData(airway))
# Restricting the data only to interesting columns
sample_info <- sample_info[,c(2,3)]
# Replacing shortcuts with proper name for column dex
sample_info$dex <- gsub('trt', 'treated', sample_info$dex)
sample_info$dex <- gsub('untrt', 'untreated', sample_info$dex)
# Renaming the column names: cell, dex to more descriptive names
names(sample_info) <- c('cellLine', 'dexamethasone')
# Writing chosen data info into csv file
write.table(sample_info, file = "sample_info.csv", sep = ',',
col.names = T, row.names = T, quote = F)
# Preparing data of experiment where rows are genes, columns are counts for each sample and gene
countsData <- assay(airway)
# Writing count data info into csv file
write.table(countsData, file = "counts_data.csv", sep = ',',
col.names = T, row.names = T, quote = F)
# Reading in counts data from csv:
counts_data<- read.csv('counts_data.csv')
# we see the rows are gene IDs (Ensemble), columns are the sample name but by this names
# we don't know which samples are treated and which one are untreated which we will set up
head(counts_data)
# Reading the sample_info:
column_data<-read.csv('sample_info.csv')
head(column_data)
# To perform calculations with DESeq we have to check the row names of column_data
# matches the names in counts_data.
# We performing this by checking if all colnames in counts_data are present in column_data
# We get the information in the boolean if there are all of them or not
all(colnames(counts_data) %in% rownames(column_data))
# In addition we check if they are in the same order:
all(colnames(counts_data) == rownames(column_data))
# First argument countData refers to counts genes accross samples, colData refers to data about cell line of each sample
# that we are checking and information about it being treated with drug or not, design is a formula which express
# how the counts for each gene depend on the variables in colData, so for our example we want to check the differences
# between treated and untreated samples so design refers to the dexamethasone column
dds <- DESeqDataSetFromMatrix(countData = counts_data,
colData = column_data,
design = ~ dexamethasone)
dds
# This step allows us to reduce the memory size of the dds object, and increase the speed
# of the transformation and testing functions with DESeq2. It can also improve visualization,
# as features with no information for differential expression will not be plotted
keeped_rows <- rowSums(counts(dds)) >= 10
dds <- dds[keeped_rows,] # we drooped ~ 40k rows with lower than 10 counts
dds
dds$dexamethasone <- relevel(dds$dexamethasone, ref = "untreated")
dds$dexamethasone
# Now the script will perform the standard differential expression analysis, which all steps are wrapped in the single
# function DESeq.
dds <- DESeq(dds)
# Saving results from DESeqData object:
res <- results(dds)
# padj - this column contains adjusted p_values for multiple testing. We have to correct the p_values
#       for multiple testing because whenever the statistical test is performed we use a p value of 0.05.
#       5% of our differential expressed genes are not really differential expressed and they are there due to random chance.
#       To reduce problem of this false positives we perform methods to calculate the adjusted p_values to avoid this detection
#       of false positive genes.
res
# In the summary we can see how many genes are up-regulated, down-regulated, how much of them are outlires
# and how many of them have low counts.
summary(res)
# Also we can change the threshold of adjusted p_values we look at
res_p_0.01 <- results(dds, alpha = 0.01)
summary(res_p_0.01)
plotMA(res, ylim=c(-2,2), main = "MA plot of airway data set")
ggsave(filename="MA_plot.png", plot=last_plot(), device="png")
# We performing this step to make more accurate log2FC estimates. This function allows for the shrinkage of the log2FC estimates
# toward zero when the information for a gene is low, which include situations like: low counts, high dispersion values. After usage of
# this function the distribution of LFC estimate for all genes is used to shrink the log2FC estimates of gene with little information
# or high dispersion toward more likely (lower LFC) estimates. (https://github.com/hbctraining/DGE_workshop_salmon/blob/master/lessons/05_DGE_DESeq2_analysis2.md)
resultsNames(dds)
# type = apeglm refers to approximate estimation for GLM coefficients which is the adaptive Student's t prior shrinkage estimator from the 'apeglm' package
resLFC <- lfcShrink(dds, coef = "dexamethasone_treated_vs_untreated", type = "apeglm")
plotMA(resLFC, main = "MA plot of airway data set after shrinkage")
ggsave(filename="MA_plot_after_shrinkage.png", plot=last_plot(), device="png")
# Plot counts - provides  the information of the counts of reads for a single gene across the analysed groups:
# for this plot was provided gen with the smallest adj. p_value from the DESeq results
plotCounts(dds, gene = which.min(res$padj), intgroup = "dexamethasone")
ggsave(filename="counts_plot.png", plot=last_plot(), device="png")
# Saving results ordered by p_pvalue:
resOrdered <- res[order(res$pvalue),]
write.csv(as.data.frame(resOrdered), file='deseq_results.csv')
res_adj_p <- subset(resOrdered, padj < 0.1)
res_adj_p
# saving filtered results:
write.csv(as.data.frame(res_adj_p), file='adj_p_results.csv')
# transformation with VST:
vsd <- vst(dds, blind = FALSE)
head(counts_data)
# After transformation
head(assay(vsd), 3)
library("pheatmap")
# selecting top 20 rows
select <- order(rowMeans(counts(dds, normalized=TRUE)), decreasing = TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("cellLine", "dexamethasone")])
pheatmap(assay(vsd)[select,], cluster_rows = FALSE, show_rownames = FALSE,
cluster_cols = FALSE, annotation = df)
ggsave(filename="heat_map.png", plot=last_plot(), device="png")
# This type of heat map give us an overview of the similarities and differences between groups of samples
# Also the hierarchical clustering is provided based on the sample to sample distance
sampleDistance <- dist(t(assay(vsd)))
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDistance)
rownames(sampleDistMatrix) <- paste(vsd$dexamethasone, vsd$cellLine, sep = "-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette(rev(brewer.pal(9, 'Greens')) )(255)
pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDistance,
clustering_distance_cols = sampleDistance,
color = colors)
ggsave(filename="sample_to_sample_distance.png", plot=last_plot(), device="png")
png(filename = "pca_plot.png")
plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"))
ggsave(filename="pca_plot.png", plot=last_plot(), device="png")
pcaData <- plotPCA(vsd, intgroup = c("cellLine", "dexamethasone"), returnData=TRUE)
# variable for showing the percentage of variance: (attr function catching only specific attribute of object)
percentVar <- round(100*attr(pcaData, "percentVar"))
# plotting our custom PCA plot with ggplot:
ggplot(pcaData, aes(PC1, PC2, color=dexamethasone, shape=cellLine))+
geom_point(size=3) +
xlab(paste0("PC1: ", percentVar[1],"% variance"))+
ylab(paste0("PC2: ", percentVar[2], "% variance"))+
coord_fixed()
ggsave(filename = "pca_custom.png", plot = last_plot(), device = "png")
